                nam     Mfree                ttl     program         ; module* Disassembled 1900/00/00 01:19:44 by Disasm v1.5 (C) 1988 by RML                use     defsfiletylg            set     Prgrm+Objctatrv            set     ReEnt+revrev             set     $01edition		set	2                mod     eom,name,tylg,atrv,start,size		BUFFSIZE	equ	80		FreeBlocks	rmb     2		; free memory blocksBlockMapSize    rmb     2		; size of block mapByteBlock       rmb     1		; MSB of bytes / blockZerosFlag       rmb     1		; zero supression flag for hex/dec outputBlockBegin      rmb     3		; block beggining addressBufStart        rmb     2		; start address of output bufferBufPtr          rmb     2		; output buffer pointerBuffer          rmb     BUFFSIZE	; output bufferMapBuf          rmb     1274		; block map buffersize            equ     .name            equ     *                fcs     /Mfree/                fcb     editionHeader                       fcs     ' Blk Begin   End   Blks  Size'                fcs     ' --- ------ ------ ---- ------'Footer          fcs     '                   ==== ======'                fcs     '            Total: 'start           equ     *                leax    Buffer,u	; point to output buffer                stx     <BufStart	; set start address                stx     <BufPtr		; and current address                lbsr    WriteBuf		                leay    <Header,pcr	; point to header                lbsr    StrYtoBuf	; put in buffer                lbsr    WriteBuf	; write it                lbsr    StrYtoBuf	; second header line follows on                lbsr    WriteBuf	; write it		                clr     <FreeBlocks	; zero free block count                clr     <FreeBlocks+1		                leax    <MapBuf,u	; point at map buffer                os9     F$GBlkMp	; get blockmap		                sty     <BlockMapSize	; save size of block map                sta     <ByteBlock	; MSB of bytes / block; Main loop, look for a free block in the map (entry of 0)		                ldy     #$0000		; count of blocks checkedMainLoop        ldu     #$0000		; number of free blocks in this run....L00AD           tst     ,x+		; is this a 0 block?                beq     L00BA		; yes.....		                leay    1,y		; add 1 to total checked                cmpy    <BlockMapSize	; have we done all yet?                bcs     L00AD		; no, keep going.....                bra     AllDone		; yes		; y is the first free block in a run, though it may be a single block run....		L00BA           tfr     y,d		; transfer to d                bsr     OutHexWord	; output it in hex                lda     <ByteBlock	; get MSB of bytes / block                pshs    y,a		; save regs                clra			; clear d                clrb; Multiply start block by block size to get beggining address		L00C4           addd    $01,s		; add block size (from stack)                dec     ,s		; decrement start block no (on stack)                bne     L00C4		; keep going till start blockno=0	                leas    $03,s		; tidy up stack		                std     <BlockBegin	; save address of beginning of block	                clr     <BlockBegin+2	; LSB will always be zero as it's on a block boundary		                bsr     OutHexAddr	; output address in hex; look for last block in this run of free blocks		L00D2           leau    1,u		; increment block run counter                leay    1,y		; increment blocks checked counter                cmpy    <BlockMapSize	; done all blocks?                beq     AllDone		; yes, skip		                tst     ,x+		; test current block in map                beq     L00D2		; it's zero, keep going		                lda     <ByteBlock	; get MSB of bytes / block                pshs    y,a		; save regs                clra			; clear d                clrb; Multiply start block by block size to get end address		L00E5           addd    $01,s		; add block size (from stack)                dec     ,s		; decrement start block no (on stack)                bne     L00E5		; keep going till start blockno=0	                leas    $03,s		; tidy up stack				subd    #$0001		; compensate for over-loop                std     <BlockBegin	; save end address                lda     #$FF		; LSB will always be $FF, as block fully occupied                sta     <BlockBegin+2		                bsr     OutHexAddr	; output end address                leax    -$01,x		; move back a block                tfr     u,d		; get number of blocks in this run into d                bsr     OutHexWord	; and output it		                lbsr    DecToBuf	; append block size in decimal		                addd    <FreeBlocks	; previous free blocks to free block count                std     <FreeBlocks	; and save it back                bsr     WriteBuf	; write current entry		                bra     MainLoop	; loop again		AllDone         leay    >Footer,pcr	; point to footer                bsr     StrYtoBuf	; put it in buffer                bsr     WriteBuf	; and write it		                bsr     StrYtoBuf	; and second line...		                tfr     u,d		; get number of blocks in this run into d                addd    <FreeBlocks	; previous free blocks to free block count                std     <FreeBlocks	; and save it back                bsr     OutHexWord	; output it in hex                bsr     DecToBuf	; and in decimal                bsr     WriteBuf	; write it	                		clrb			; no error                os9     F$Exit		; exitOutHexWord      pshs    d		; save word to output                clr     <ZerosFlag	; no leading zeros                bsr     DoHexOut	; output MSB                tfr     b,a		; and LSB                bsr     DoHexOut                lda     #' '		; And a space                bsr     StoreAInBuf                puls    pc,d		OutHexAddr      clr     <ZerosFlag	; suppress leading zeros                lda     <BlockBegin	; get MSB                bsr     DoHexOut	; output it                lda     <BlockBegin+1	; get middle byte                bsr     DoHexOut	; output it	                lda     <BlockBegin+2	; and LSB                bsr     DoHexOut	; output it                lda     #' '		; Output a space                 bra     StoreAInBuf		DoHexOut        pshs    a		; save value to convert                lsra			; move top nibble to bottom nibble bits                lsra                lsra                lsra                bsr     L014F		; convert to ascii                		puls    a		; restore value to convertL014F           anda    #$0F		; mask bottom nibble                tsta			; zero?                beq     L0156		; yes, check for zeros flag		                sta     <ZerosFlag	; otherwise set zeros flag, so zeros output from now onL0156           tst     <ZerosFlag	; check zeros flag                bne     L015C		; set, so just output digit                lda     #$F0		; this value when added below will produce space.....		L015C           adda    #'0'		; convert to ascii '0'..'9'                cmpa    #':'		; bigger than 9?                bcs     StoreAInBuf	; no go store it                adda    #$07		; convert to 'A'..'F'		StoreAInBuf     pshs    x               ; save x                ldx     <BufPtr       	; point x at buffer                   sta     ,x+             ; save a in buffer                stx     <BufPtr         ; save buffer pointer                puls    pc,x            ; restore and returnWriteBuf       	pshs    y,x,a		; save regs                lda     #C$CR		; Put a CR in buffer		                bsr     StoreAInBuf		                ldx	<BufStart	; point at beginning of buffer                stx     <BufPtr		; put in buffer pointer                		ldy     #BUFFSIZE	; Write the whole buffer                lda     #$01		; standard out	                os9     I$WritLn	; write it                puls    pc,y,x,a	; restore and return			StrYtoBuf       lda     ,y 		; get byte from message                             anda    #$7F            ; reset bit 7                bsr     StoreAInBuf     ; store it in buff                      tst     ,y+             ; check next char from string                bpl     StrYtoBuf       ; loop again if not end of string                rts		DecadeTab	fdb	10000,1000,100,10,1		fcb	$ffDecToBuf	pshs	x,y,d		; save regs		                lda     <ByteBlock	; get bytes / block                pshs    a		; save it on stack                lda     $01,s                lsr     ,s                lsr     ,s                bra     L01A9L01A7           lslb                rola		L01A9           lsr     ,s                bne     L01A7		                leas    $01,s                leax    <DecadeTab,pcr                ldy     #$2F20L01B6           leay    >$0100,y                subd    ,x                bcc     L01B6                addd    ,x++                pshs    b,a                tfr     y,d                tst     ,x                bmi     L01DE                ldy     #$2F30                cmpd    #$3020                bne     L01D8                ldy     #$2F20                lda     #$20L01D8           bsr     StoreAInBuf                puls    b,a                bra     L01B6L01DE           bsr     StoreAInBuf                lda     #$6B                bsr     StoreAInBuf                leas    $02,s                puls    pc,y,x,b,a                emodeom             equ     *                end