                nam     OS9gen                          ttl     program         ; module                                        * Disassembled 1900/00/00 01:25:12 by Disasm v1.5 (C) 1988 by RML** Disassembled from original Dragon Data Beta OS9.* Tidyed up and commented 2022-05-03, PHS.                                        *                                                use     defsfile                 tylg            set     Prgrm+Objct     atrv            set     ReEnt+rev       rev             set     $01                             						mod     eom,name,tylg,atrv,start,size InBufSize	equ	$400StatPtr         rmb     2               ; statics pointerTempFID         rmb     1               ; temporary file idDevID           rmb     1  		; device file id             InFID           rmb     1               u0005           rmb     1               TempFileSize    rmb     2               DDBT		rmb	3		; local copy of bootfile first sector locDDBSZ           rmb     2               ; local copy of bootfile sizeNameLen         rmb     2               StatBuf         rmb     32              DevNameEnd      rmb     2               ; pointer ro end of device nameDevName         rmb     32		; device name copied from command line              InNameBuf       rmb     16		; buffer for input filenames              u0061           rmb     1               u0062           rmb     7               u0069           rmb     1450            size            equ     .               name            equ     *                               fcs     /OS9gen/        edition			set		5                fcb     edition				HelpMsg         fcb   	C$LF		fcc   	"Use (caution): os9gen </devname>"		fcb   	C$LF		fcc   	" ..reads (std input) pathnames until eof,"		fcb   	C$LF		fcc   	"   merging paths into new os9boot file."		fcb   	C$CR		fcc   	"Can't find: "   ErrorMsg        fcb     C$LF		fcc	"ERROR - os9boot file not contiguous"		fcb     C$LF		fcc	" This disk will not bootstrap."		fcb	C$CR               RenameCmd       fcc	"RENAME "				TempFileName    fcc	"TempBoot "		fcb	$FF				BootFileName    fcc	"OS9Boot"		fcb	C$CR		fcb	$FFstart           equ     *                               clrb                                    stb     <u0005   	; zero u0005                       stu     <StatPtr      	; save pointer to working storage  	                  lda     #'/'           	; check for slash                cmpa    ,x              ; at start of in given filename                lbne    HelpExit  	; nope, give help and exit		                         os9     F$PrsNam        ; parse the name                lbcs    HelpExit       	; error, give help and exit; x now points to the first character of the device name; y now points to the seperater between device name and file/path name; b has the number of bytes in device name				                lda     #'/'  		; check last character of supplied device                          cmpa    ,y              ; for a slash                lbeq    HelpExit  	; error, give help and exit if so                         leay    <DevName,u   	; dev name bufferL0111           sta     ,y+             ; save char in buffer                lda     ,x+             ; get next char                decb                    ; decrement counter                bpl     L0111           ; keep going if not zero				                sty     <DevNameEnd     ; save end of output device                    lda     #'@'          	; terminate device name with @  	                ldb     #' '            ; so we can open the whole device file                std     ,y++			                            		leax    <DevName,u     	; point to device name                   lda     #UPDAT.		; open it for update                            os9     I$Open          ; go open it                sta     <DevID          ; save file id                lbcs    HelpExit       	; error, display help and exit                    ldx     <DevNameEnd     ; point at end of device name                     leay    >TempFileName,pcr	; point at temporary filename                      lda     #'/'            ; put a seperator inL0137           sta     ,x+             ; copy characters from temp name to devname                lda     ,y+                             bpl     L0137           ; until end of temp filename				                leay    >BootFileName,pcr	; point at boot file name      L0141           lda     ,y+             ; copy that to end as well....                sta     ,x+                             bpl     L0141    	; until end of name                       tfr     x,d             ; save pointer in d                leax    <DevName,u     	; point to temp filename                   pshs    x               ; save it                subd    ,s++            ; calculate length of name                std     <NameLen        ; save it                  lda     #WRITE.		; write access mode                            ldb     #UPDAT.    	; attributes                        os9     I$Create        ; create file                sta     <TempFID                          lbcs    Exit           	; error, exit		                ldx     #$0000  	; LSW of filesize = 0	                        stx     <TempFileSize   ; zero temp filesize                       ldu     #$4000          ; MSW of filesize = 0                ldb     #SS.Size        ; set filesize                     os9     I$SetStt      	; try setting it                lbcs    Exit     	; error, exit                      ldu     <StatPtr      	; recover statics pointer    ReadNextInput   clra                                    leax    <InNameBuf,u	; point to name for each filename to read                        ldy     #InBufSize      ; size of buffer = 1K                os9     I$ReadLn        ; go read a line                bcs     L01CA           ; check for eof etc		                lda     ,x		; get byte read                              ldb     #$D3                            cmpa    #$0D            ; Was it just a return = end of input?                beq     L01CA           ; yes : deal with it		                lda     #READ.		; open specified filename for read                            os9     I$Open                          bcs     L01B9           ; error, skip		                sta     <InFID        	; save input file ID  L0190           lda     <InFID          ; get input file ID                leax    <InNameBuf,u    ; point at input buffer                    ldy     #InBufSize	; buffer size                os9     I$Read          ; read some bytes from input file                          bcs     L01AE           ; error (or end of file) 		                tfr     y,d             ; get number of bytes read                addd    <TempFileSize   ; add to temp filesize                       std     <TempFileSize                          lda     <TempFID        ; get file ID of temp file                  os9     I$Write         ; write the bytes                bcc     L0190           ; no error, loop for more input bytes                lbra    Exit       	; error, exit    L01AE           cmpb    #$D3            ; end of file?                lbne    Exit           	; nope, exit                os9     I$Close         ; close input file                bra     ReadNextInput   ; loop to read next file 		L01B9           pshs    b     		; save error code                          leax    <InNameBuf,u 	; point to read data                       ldy     #$0100          ; 256 bytes                lda     #$02            ; standard error                os9     I$WritLn        ; write itL01C7           lbra    Exit            ; exitL01CA           cmpb    #$D3            ; end of file ?                bne     L01C7           ; nope, exit		                leax    StatBuf,u      	; point at stat buffer                   ldb     #SS.Opt		; get option area                            lda     <TempFID     	; for temporary file                     os9     I$GetStt        ; go get stats                lbcs    Exit           	; error, exit		                lda     <TempFID        ; get temp file id                  ldx     #$0000          ; MSW of filesize = 0                ldu     <TempFileSize  	; get LSW of filesize, calculated                        ldb     #SS.Size	; set filesize                            os9     I$SetStt        ; set the filesize                lbcs    Exit           	; error, exit		                ldu     <StatPtr      	; point at Static storage                    os9     I$Close         ; close temp file                lbcs    HelpExit       	; error, display help and exit                    ldx     StatBuf+(PD.FD-PD.OPT),u	; get LSN of file descriptor                        lda     StatBuf+(PD.FD-PD.OPT)+2,u  	; returned in X:a                      clrb       			; convert lsb to word                             tfr     d,u             ; and put in u                lda     <DevID          ; get device file ID                os9     I$Seek 		; seek to sector                         ldu     <StatPtr      	; recover statics pointer                    lbcs    Exit           	; seek error, exit		                leax    <InNameBuf,u 	; point to name buffer                       ldy     #$0100          ; read 256 bytes                os9     I$Read          ; go read them                lbcs    Exit           	; exit on error		                ldd     <InNameBuf+(FD.SEG+FDSL.S+FDSL.B),u	; get segment count                        lbne    ErrorMsgExit 	; not zero, exit, file is fragmented.                          lda     <DevID 		; get device FID                         ldx     #$0000          ; seek to bootfile start sector offset                ldu     #DD.BT                          os9     I$Seek		; do seek                          ldu     <StatPtr      	; recover statics pointer                    lbcs    Exit           	; exit on error		                leax    DDBT,u         	; point to copy in statics                ldy     #DD.DAT-DD.BT	; we want DD.BT and DD.BTSZ                         os9     I$Read          ; read them                lbcs    Exit           	; error, exit                		ldd     <DDBSZ		; get size of exitsting bootfile                          beq     L0261          	; zero we can continue....                 ldx     <DevNameEnd   	; point at end of dev name                       leay    >BootFileName,pcr	; point at bootfile name                      lda     #'/'            ; start with path seperatorL0247           sta     ,x+             ; write byte to dev name                lda     ,y+             ; get byte from bootfile name                bpl     L0247           ; keep going if more		                leax    <DevName,u    	; point at devname + bootfilename                    os9     I$Delete        ; delete old bootfile		                ldx     <DevNameEnd    	; point at end of device name                      leay    >TempFileName,pcr      ; and beginning of tempfilename                lda     #'/'            ; insert path seperatorL025B           sta     ,x+             ; copy bytes                lda     ,y+                             bpl     L025B           ; keep going till end			L0261           lda     #$01                            clrb                                    leax    >RenameCmd,pcr	; point to rename command                      ldy     <NameLen     	; get name length                     leau    <DevName,u   	; point to device/newname                     os9     F$Fork          ; fork off rename command		                bcs     Exit           	; error, exit		                os9     F$Wait          ; wait for forked rename to finish                bcs     Exit           	; error, exit		                tstb                    ; wait returned error code?                bne     Exit           	; yex exit                		ldu     <StatPtr     	; point back at statics                     ldb     <u0061,u                        stb     <DDBT                          ldd     <u0062,u                        std     <DDBT+1                          ldd     <TempFileSize                          std     <DDBSZ                  ldx     #$0000          ; seek to bootfile start sector offset                ldu     #DD.BT          		lda	<DevID		; get device file id                os9     I$Seek		; do seek                          ldu     <StatPtr      	; recover statics pointer                    bcs    	Exit           	; exit on error                        leax    DDBT,u         	; point to local boot location & size                ldy     #DD.DAT-DD.BT	; we want DD.BT and DD.BTSZ                os9     I$Write         ; write them to disk                bcs     Exit           	; error, exit		                os9     I$Close         ; close dev file                bcs     Exit           	; error, exit		                clrb                    ; flag no error                bra     Exit           	; and exitHelpExit        leax    >HelpMsg,pcr  	; point at help message    MessXExit       pshs    b               ; save error code                lda     #$02            ; error channel                ldy     #$0100     		; 256 bytes should be enough for message!                     os9     I$WritLn        ; write it                puls    b               ; restore error code	Exit            os9     F$Exit          ; exitErrorMsgExit    leax    >ErrorMsg,pcr	; point at error message                      clrb                    ; no error	                bra     MessXExit     	; print it and exit                      emod                    eom             equ     *                               end                     